#ifndef CHOLESKY_HPP
#define CHOLESKY_HPP

#include <sycl/sycl.hpp>

#include "LoadBalancer.hpp"
#include "MetricsTracker.hpp"
#include "SymmetricMatrix.hpp"

using namespace sycl;

/**
 * This class contains the heterogeneous implementation of the Cholesky decomposition.
 */
class Cholesky {
public:
    Cholesky(SymmetricMatrix& A, queue& cpuQueue, queue& gpuQueue, std::shared_ptr<LoadBalancer> loadBalancer);
    ~Cholesky();

    SymmetricMatrix& A; /// SPD matrix A
    conf::fp_type* A_gpu; /// GPU data structure for A


    queue& cpuQueue; /// SYCL queue for the CPU device
    queue& gpuQueue; /// SYCL queue for the GPU device

    std::shared_ptr<LoadBalancer> loadBalancer; /// load balancer to dynamically or statically determine the CPU/GPU split
    MetricsTracker metricsTracker; /// metrics tracker that tracks various runtime metrics

    double gpuProportion; /// current GPU proportion


    void solve_heterogeneous(); /// main method that starts the heterogeneous Cholesky decomposition

    void writeMetricsToFile(); /// writes the json file generated by the metrics tracker with all runtime metrics

private:
    /// struct that stores various execution times of the steps of the algorithm
    struct executionTimes {
        std::chrono::time_point<std::chrono::steady_clock> start;
        std::chrono::time_point<std::chrono::steady_clock> end;


        std::chrono::time_point<std::chrono::steady_clock> startMemoryInitGPU;
        std::chrono::time_point<std::chrono::steady_clock> endMemoryInitGPU;

        std::chrono::time_point<std::chrono::steady_clock> startColumn;

        std::chrono::time_point<std::chrono::steady_clock> startCholesky;
        std::chrono::time_point<std::chrono::steady_clock> endCholesky;

        std::chrono::time_point<std::chrono::steady_clock> startCopy_row;
        std::chrono::time_point<std::chrono::steady_clock> endCopy_row;

        std::chrono::time_point<std::chrono::steady_clock> startCopy_column;
        std::chrono::time_point<std::chrono::steady_clock> endCopy_column;

        std::chrono::time_point<std::chrono::steady_clock> startTriangularSolve;
        std::chrono::time_point<std::chrono::steady_clock> endTriangularSolve;

        std::chrono::time_point<std::chrono::steady_clock> startMatrixMatrixDiagonal;
        std::chrono::time_point<std::chrono::steady_clock> endMatrixMatrixDiagonal;

        std::chrono::time_point<std::chrono::steady_clock> startMatrixMatrix;
        std::chrono::time_point<std::chrono::steady_clock> endMatrixMatrix;

        std::chrono::time_point<std::chrono::steady_clock> startResultCopyGPU;
        std::chrono::time_point<std::chrono::steady_clock> endResultCopyGPU;

        sycl::event eventCPU_matrixMatrix;
        sycl::event eventGPU_matrixMatrix;

        sycl::event eventCPU_matrixMatrixDiag;
        sycl::event eventGPU_matrixMatrixDiag;

        sycl::event eventCPU_triangularSolve;
        sycl::event eventGPU_triangularSolve;
    } executionTimes;

    // variables
    int blockCountGPU;
    int blockCountCPU;
    int blockStartGPU;
    int offsetMatrixMatrixStepGPU = 0;
    int minBlockCountGPU;

    /**
     * Operation that waits on the CPU and GPU queue
     */
    void waitAllQueues();

    /**
     * Operation that initializes the GPU memory
     */
    void initGPUMemory();

    /**
     * Operation that initializes the execution times struct
     */
    void initExecutionTimes();

    /**
     * This operation shifts the horizontal split between the CPU and GPU up or down depending on the new desired GPU proportion.
     * It ensures consistency of the matrix across the CPU and GPU after split is shifted.
     */
    void shiftSplit(int blockCountATotal, std::size_t blockSizeBytes, int k, std::size_t blockStartIndexDiagBlock);

    /**
     * Performs the first step of a column step of the Cholesky decomposition: a small Cholesky decomposition of the current diagonal block.
     *
     * @param blockSizeBytes size of one block in bytes
     * @param k column k
     * @param blockID id of the diagonal block
     * @param blockStartIndexDiagBlock start index of the diagonal block in the data structure
     */
    void choleskyUpdateCurrentDiagonalBlock(std::size_t blockSizeBytes, int k, int blockID, std::size_t blockStartIndexDiagBlock);

    /**
     * Performs the second step of a column step of the Cholesky decomposition: updating the column below the diagonal block by
     * solving a matrix equation.
     *
     * @param blockSizeBytes size of one block in bytes
     * @param k column k
     * @param blockID id of the diagonal block
     */
    void choleskySolveTriangularSystemColumn(std::size_t blockSizeBytes, int k, int blockID);

    /**
     * Performs the third step of a column step of the Cholesky decomposition: updating the remaining diagonal blocks
     * using symmetric matrix-matrix multiplications
     *
     * @param k column k
     * @param blockID id of the diagonal block
     */
    void choleskyUpdateDiagonal(int k, int blockID);

    /**
     * Performs the third step of a column step of the Cholesky decomposition: updating the remaining non-diagonal blocks
     * using matrix-matrix multiplications.
     *
     * @param k
     * @param blockID
     */
    void choleskyUpdateLowerBlockTriangle(int k, int blockID);

    /**
     * Prints the runtimes of the individual steps for the current column processing step
     *
     * @param k column k
     */
    void printTimes(int k);

    /**
     * This operation copies the part of the final lower triangular matrix computed on the GPU to the CPU after the decomposition
     *
     * @param blockCountATotal Total amount of blocks stored for the matrix A
     * @param blockSizeBytes size of one block in bytes
     */
    void copyResultFromGPU(int blockCountATotal, std::size_t blockSizeBytes);

    /**
     * Prints the final runtimes of the complete decomposition
     */
    void printFinalTimes();
};


#endif //CHOLESKY_HPP
